
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Algorithme de Pledge</h2>

<p>Une fois de plus, vous pensiez que votre algorithme vous permettait de vous
?chapper des labyrinthes, et une fois de plus, votre buggle est prise dans
un labyrinthe mettant votre algorithme en d?faut. Essayez de copier votre
code et de l'ex?cuter pour voir : votre cr?ation pr?c?dente ?choue
lamentablement. Le pi?ge a la forme d'un ?G? majuscule : la buggle entre
dans le pi?ge, suit le bord interne. Au bout d'un moment, la direction nord
est libre et votre buggle se met donc ? courir dans cette direction. Pour
retomber dans le pi?ge...
</p>

<p>L'algorithme de Pledge (nomm? d'apr?s Jon Pledge d'Exeter) peut sortir de ce
labyrinthe.</p> 

<p>Cet algorithme est une version modifi?e de l'algorithme pr?c?dent con?u pour
?viter les obstacles. Il n?cessite de choisir de mani?re arbitraire une
direction vers laquelle la buggle se dirigera. Quand un obstacle est
rencontr?, une patte (disons la patte de gauche) est gard?e le long des
obstacles tandis que les virages sont comptabilis?s. Quand la buggle est
face ? nouveau ? la direction originale, et que la somme des virages est
?gale ? 0, la buggle quitte l'obstacle et continue de se d?placer dans sa
direction d'origine. </p>

<p>Notez que l'utilisation de la "somme des virages" ? la place de la
"direction courante" permet ? l'algorithme d'?viter les pi?ges tel que les
formes en "G" majuscule. Si l'on rentre par la gauche dans le pi?ge, on
tourne de 360 degr?s autour des murs. Un algorithme qui se contenterait
na?vement de se retrouver dans la m?me direction qu'? l'origine rentre dans
un cycle infini puisque qu'il quitte le mur le plus ? droite en ?tant dirig?
vers la gauche, et entre ? nouveau dans la section incurv?e.</p>

<p>L'algorithme de Pledge ne quitte pas le mur en bas ? droite puisque la somme
des virages ne vaut pas z?ro ? ce moment. Il continue de suivre le mur
jusqu'? avoir compl?tement fait le tour, et le quitte en regardant ? gauche
une fois parvenu sous l'obstacle.</p>


<h3>Objectif de cet exercice</h3>

<p><a name="Objectifs"/> L'objectif de cet exercice est d'?crire une
impl?mentation de l'algorithme de Pledge qui permettra ? votre buggle de
sortir du labyrinthe.</p>

<p>Reprenez la m?thode <code>keepHandOnSideWall()</code> de l'exercice
pr?c?dent. Modifiez cette m?thode pour compter les virages pris par votre
buggle (+1 lorsqu'il a tourn? ? gauche par rapport ? son origine, -1
lorsqu'il a tourn? ? droite). Pour comptabiliser vous aurez besoin d'ajouter
une variable <code>sommeAngle</code> de type enti?re ? votre programme.</p>

<p>?crivez une m?thode bool?enne <code>isDirectionFree(dir)</code> indiquant si
la direction fournie en param?tre est libre, c'est-?-dire si vous pouvez
vous d?placer dans cette direction. Notez que la d?mo utilise la direction
NORD pour cela. Vous pouvez retrouver la direction courante de la buggle en
utilisant la m?thode <code>Direction getDirection()</code>.  Vous pouvez
diriger (sans se d?placer) votre buggle dans une direction en utilisant la
m?thode <code>setDirection(dir)</code>.  Pensez ? m?moriser (dans une
variable d?di?e) la direction courante de votre buggle avant de v?rifier si
votre buggle peut se diriger vers sa direction de pr?dilection pour pouvoir
restaurer l'?tat apr?s coup.</p>

<p>Vous pouvez ?tre amen?s ? modifier ?galement le reste de votre code, mais
ces changements devraient rester limit?s.</p>



<a href="#tip-1">Montrer un indice suppl?mentaire</a>
	
