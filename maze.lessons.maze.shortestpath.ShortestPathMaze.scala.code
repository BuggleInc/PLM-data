def markGround(){
  var baggleX:Int = 0
  var baggleY:Int = 0
  for(i <- 0 to getWorldWidth() - 1)
  	for(j <- 0 to getWorldHeight() - 1)
  		if(hasBaggle(i, j)){
  			baggleX = i
  			baggleY = j
			}
  markCell(baggleX, baggleY, 0)
}

def markCell(x:Int, y:Int, dis:Int){
  if(getIndication(x, y) > dis)
    setIndication(x, y, dis)
  if(y != 0 && !hasTopWall(x, y) && getIndication(x, y - 1) > dis + 1)
    markCell(x, y - 1, dis + 1)
  if(y != getWorldHeight() - 1 && !hasBottomWall(x, y) && getIndication(x, y + 1) > dis + 1)
    markCell(x, y + 1, dis + 1)
  if(x != 0 && !hasLeftWall(x, y) && getIndication(x - 1, y) > dis + 1)
    markCell(x - 1, y, dis + 1)
  if(x != getWorldWidth() - 1 && !hasRightWall(x, y) && getIndication(x + 1, y) > dis + 1)
    markCell(x + 1, y, dis + 1)
}
     
def hasBottomWall(x:Int, y:Int) : Boolean = {
  if(hasTopWall(x, y + 1))
  	return true
  else
  	return false
}

     
def hasRightWall(x:Int, y:Int) : Boolean = {
  if(hasLeftWall(x + 1, y))
  	return true
  else
  	return false
}

def followPath(cur:Int){
  if(getY() != 0 && !hasTopWall(getX(), getY()) && getIndication(getX(), getY() - 1) < cur){
    setDirection(Direction.NORTH)
    forward()
  }
  if(getY() != getWorldHeight() - 1 && !hasBottomWall(getX(), getY()) && getIndication(getX(), getY() + 1) < cur){
    setDirection(Direction.SOUTH)
    forward()
  }
  if(getX() != 0 && !hasLeftWall(getX(), getY()) && getIndication(getX() - 1, getY()) < cur){
    setDirection(Direction.WEST)
    forward()
  }
  if(getX() != getWorldWidth() - 1 && !hasRightWall(getX(), getY()) && getIndication(getX() + 1, getY()) < cur){
    setDirection(Direction.EAST)
    forward()
  }
  
  if(!isOverBaggle())
  	followPath(cur - 1)
  else
  	pickupBaggle()
}

override def run() {
  markGround()
  followPath(getIndication(getX(), getY()))
}