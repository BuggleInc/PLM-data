override def run() {
  var x = 0
  var y = 0 
  var i = 0
  var indic=0
  val L:Int=getMondeLargeur()
  val H:Int=getMondeHauteur()
  val xBis = trouverBis(0,H,L)
  val yBis = trouverBis(1,H,L)
  setIndication(xBis,yBis,0)
  while(!fini(H,L)){
    for (x<-0 to L-1; y<- 0 to H-1){
      if (getIndication(x,y)!=9999){
        indic = getIndication(x,y)
        ecrireAdj(x,y,indic,H,L)
      }
    }
   }
}

def trouverBis(i:Int,H:Int,L:Int):Int = {
  // i = 0 pour x, 1 pour y
  var abscisse = 0
  var ordonnee = 0
  for (abscisse <- 0 to L-1){
    for (ordonnee <- 0 to H-1){
      if (aBiscuit(abscisse,ordonnee)){
        i match{
          case 0 => return abscisse
          case 1 => return ordonnee
        }
      }
    }
  }
  println("erreur")
  return 0
} // permet de trouver la valeur x (i=0) ou y (i=1) du Biscuit

def fini(H:Int,L:Int):Boolean={
  var x=0
  var y=0
  for (x <- 0 to L-1){
    for (y<- 0 to H-1){
      if (getIndication(x,y)==9999){
        return false
      }
    }
  }
  return true
} // permet de voir si toutes les cases ont été marquées

def ecrireAdj(x:Int,y:Int,indic:Int,H:Int,L:Int){
  var adjX = 0
  var adjY = 0
  for (adjX <- -1 to 1;adjY <- -1 to 1){
    if (Math.abs(adjX)+Math.abs(adjY)==1 && 0<x+adjX &&x+adjX<L && 0<y+adjY && y+adjY<H){
      adjX match{
        case -1 => if(!aMurOuest(x,y) && getIndication(x+adjX,y+adjY)==9999){setIndication(x+adjX,y+adjY,indic+1)}
        case 1 => if (!aMurOuest(x+adjX,y+adjY) && getIndication(x+adjX,y+adjY)==9999){setIndication(x+adjX,y+adjY, indic+1)}
        case _ => println("rien")
      }
      adjY match{
        case -1 => if(!aMurNord(x+adjX,y+adjY) && getIndication(x+adjX,y+adjY)==9999){setIndication(x+adjX,y+adjY, indic+1)}
        case 1 => if(!aMurNord(x,y) && getIndication(x+adjX,y+adjY)==9999){setIndication(x+adjX,y+adjY, indic+1)}
        case _ => println("rien")
      }
    }
  }
}