<html><head>  <style type="text/css">
    body { font-family: tahoma, "Times New Roman", serif; font-size:10px; margin:10px; }
    code { background:#EEEEEE; }
    pre { background: #EEEEEE;
          margin: 5px;
          padding: 6px;
          border: 1px inset;
          width: 640px;
          overflow: auto;
          text-align: left;
          font-family: "Courrier New", "Courrier", monospace; }
   .comment { background:#EEEEEE;
              font-family: "Times New Roman", serif;
              color:#00AA00;
              font-style: italic; }
  </style>
<<<<<<< HEAD
</head><body>
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Fonctions</h2>

<p>Souvent, on souhaite écrire une méthode calculant une valeur donnée, et qui
la retourne. On appelle <b>fonctions</b> ces méthodes qui renvoient un
résultat.Écrire une fonction n'est pas tellement plus dur que pour les
méthodes sans résultat.

Il suffit d'ajouter deux points (:), le type de données renvoyées
par votre fonction et le signe égal (=) entre  les parenthèses de la
déclaration et l'accolade du bloc. Cette syntaxe est assez proche de la
définition d'une variable (avec son type) dont la valeur serait une
fonction.
Vous pouvez utiliser l'instruction <code>return</code> n'importe ou dans le
corps de votre fonction pour spécifier que le calcul est fini (la suite de
la fonction n'est pas exécutée) et donner la valeur à donner à l'appelant
après le mot-clé <code>return</code>.</p>

<pre>def pi(): Double = {
    return 3.14159
}</pre>

<p>En fait, vous pouvez également utiliser le mot-clé <code>return</code> dans
les méthodes ne renvoyant pas de résultat, pour interrompre leur
exécution. Dans ce cas, il ne faut bien entendu pas donner de valeur à
droite du <code>return</code>.</p>

<p>Il est possible d'avoir plusieurs instructions <code>return</code> dans
différentes branches de <code>if</code>. Ce qui est interdit, c'est d'avoir
une branche du code qui n'est pas terminée par un <code>return</code>, ou
d'écrire du code après le <code>return</code>.
En effet, si la machine arrive à la fin de la fonction sans avoir rencontré
de <tt>return</tt>, elle ne peut pas savoir quelle valeur communiquer à
celui qui a appelé la fonction. De plus, le <tt>return</tt> interrompt
immédiatement l'exécution de la fonction (pourquoi continuer à chercher
quand on a déjà trouvé le résultat de la fonction?). Donc, s'il y a du code
après un <tt>return</tt>, c'est sans doute une erreur, et le compilateur
vous l'indique.</p>

<pre> def estDevantLibre():Boolean = {
    if (estFaceMur() == true) {
        return false;
        <span class="comment">/* interdit d'écrire du code ici */</span>
    } else {
        return true;
        <span class="comment">/* pareil ici */</span>
    }
    <span class="comment">/* même ici, oubliez */</span>
}[/!]</pre>

<h3>Objectif de cet exercice</h3>Vous allez encore une fois écrire une fonction qui sera utilisée par la
buggle. Son nom doit être <code>haveBaggle</code>, et elle doit renvoyer un
booléen indiquant si la colonne face à la buggle contient un biscuit ou
non. Votre buggle va s'en servir pour chercher la première colonne contenant
un biscuit et s'y arrêter.

<p>Le plus simple pour écrire cette fonction est peut être d'utiliser une
variable booléenne <code>vuBiscuit</code> indiquant si on a vu un biscuit
jusque là. Initialement, elle contient faux.</p>

<p>Ensuite, on avance de 6 cases (le monde contient 7 cases, et on est déjà sur
l'une d'entre elles). Pour chaque case, si elle contient un biscuit, on
range la valeur vrai dans <tt>vuBiscuit</tt> (et on ne fait rien d'autre
qu'avancer si non).</p>

<p>Quand on est arrivé à la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBiscuit</tt> à l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu déroulant de sélection du monde
(juste sous la barre de réglage de la vitesse) permet de spécifier le monde
que vous souhaitez observer. </p>

<p>Quand votre fonction <tt>haveBaggle</tt> fonctionne, passez à l'exercice
suivant.</p>

=======
</head><body>
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Fonctions</h2>

<p>Souvent, on souhaite Ã©crire une mÃ©thode calculant une valeur donnÃ©e, et qui
la retourne. On appelle <b>fonctions</b> ces mÃ©thodes qui renvoient un
rÃ©sultat.Ã‰crire une fonction n'est pas tellement plus dur que pour les
mÃ©thodes sans rÃ©sultat.

Il suffit d'ajouter deux points (:), le type de donnÃ©es renvoyÃ©es
par votre fonction et le signe Ã©gal (=) entre  les parenthÃ¨ses de la
dÃ©claration et l'accolade du bloc. Cette syntaxe est assez proche de la
dÃ©finition d'une variable (avec son type) dont la valeur serait une
fonction.
Vous pouvez utiliser l'instruction <code>return</code> n'importe ou dans le
corps de votre fonction pour spÃ©cifier que le calcul est fini (la suite de
la fonction n'est pas exÃ©cutÃ©e) et donner la valeur Ã  donner Ã  l'appelant
aprÃ¨s le mot-clÃ© <code>return</code>.</p>

<pre>def pi(): Double = {
    return 3.14159
}</pre>

<p>En fait, vous pouvez Ã©galement utiliser le mot-clÃ© <code>return</code> dans
les mÃ©thodes ne renvoyant pas de rÃ©sultat, pour interrompre leur
exÃ©cution. Dans ce cas, il ne faut bien entendu pas donner de valeur Ã 
droite du <code>return</code>.</p>

<p>Il est possible d'avoir plusieurs instructions <code>return</code> dans
diffÃ©rentes branches de <code>if</code>. Ce qui est interdit, c'est d'avoir
une branche du code qui n'est pas terminÃ©e par un <code>return</code>, ou
d'Ã©crire du code aprÃ¨s le <code>return</code>.
En effet, si la machine arrive Ã  la fin de la fonction sans avoir rencontrÃ©
de <tt>return</tt>, elle ne peut pas savoir quelle valeur communiquer Ã 
celui qui a appelÃ© la fonction. De plus, le <tt>return</tt> interrompt
immÃ©diatement l'exÃ©cution de la fonction (pourquoi continuer Ã  chercher
quand on a dÃ©jÃ  trouvÃ© le rÃ©sultat de la fonction?). Donc, s'il y a du code
aprÃ¨s un <tt>return</tt>, c'est sans doute une erreur, et le compilateur
vous l'indique.</p>

<pre> def estDevantLibre():Boolean = {
    if (estFaceMur() == true) {
        return false;
        <span class="comment">/* interdit d'Ã©crire du code ici */</span>
    } else {
        return true;
        <span class="comment">/* pareil ici */</span>
    }
    <span class="comment">/* mÃªme ici, oubliez */</span>
}[/!]</pre>

<h3>Objectif de cet exercice</h3>Vous allez encore une fois Ã©crire une fonction qui sera utilisÃ©e par la
buggle. Son nom doit Ãªtre <code>haveBaggle</code>, et elle doit renvoyer un
boolÃ©en indiquant si la colonne face Ã  la buggle contient un biscuit ou
non. Votre buggle va s'en servir pour chercher la premiÃ¨re colonne contenant
un biscuit et s'y arrÃªter.

<p>Le plus simple pour Ã©crire cette fonction est peut Ãªtre d'utiliser une
variable boolÃ©enne <code>vuBiscuit</code> indiquant si on a vu un biscuit
jusque lÃ . Initialement, elle contient faux
(Â«Â»).</p>

<p>Ensuite, on avance de 6 cases (le monde contient 7 cases, et on est dÃ©jÃ  sur
l'une d'entre elles). Pour chaque case, si elle contient un biscuit, on
range la valeur vrai dans <tt>vuBiscuit</tt> (et on ne fait rien d'autre
qu'avancer si non).</p>

<p>Quand on est arrivÃ© Ã  la fin, on recule de 6 cases, et on retourne le
contenu de <tt>vuBiscuit</tt> Ã  l'appelant.</p>


<p>Cet exercice est un peu particulier, puisqu'il a deux mondes initiaux,
chacun ayant un objectif particulier. Votre code doit fonctionner pour
chacun d'entre eux. Remarquez que le menu dÃ©roulant de sÃ©lection du monde
(juste sous la barre de rÃ©glage de la vitesse) permet de spÃ©cifier le monde
que vous souhaitez observer. </p>

<p>Quand votre fonction <tt>haveBaggle</tt> fonctionne, passez Ã  l'exercice
suivant.</p>

>>>>>>> refs/remotes/origin/PLMb08ec186b1914e03e4bcaec7e8fa4fbcab29c7cd
</body></html>
