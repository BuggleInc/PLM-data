<html><head>  <style type="text/css">
    body { font-family: tahoma, "Times New Roman", serif; font-size:10px; margin:10px; }
    code { background:#EEEEEE; }
    pre { background: #EEEEEE;
          margin: 5px;
          padding: 6px;
          border: 1px inset;
          width: 640px;
          overflow: auto;
          text-align: left;
          font-family: "Courrier New", "Courrier", monospace; }
   .comment { background:#EEEEEE;
              font-family: "Times New Roman", serif;
              color:#00AA00;
              font-style: italic; }
  </style>
</head><body>
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h1>Vettori ed Intrecci</h1>

L'obbiettivo di questo esercizio è di riprodurre lo stesso pattern presente
sulla prima colonna nelle altre con uno sfasamento di una cella (guarda la
scheda objective per capire). La grande differenza fra questo esercizio e
gli altri dove avevamo dei pattern è che questa volta dobbiamo leggere il
pattern (sulla prima colonna) prima di riprodurlo.  Non puoi fare
diversamente perché lo stesso codice dovrà essere eseguito su tre differenti
mondi, ognuno di essi avente un pattern specifico.

<p>Una soluzione è quella di leggere la cella successiva e copiarla prima di
tornare indietro a leggere la seconda cella. Ma visto che non è consentito
l'utilizzo del metodo per teletrasportare il buggle in una specifica
posizione (<code>setPos()</code> e simili), questo approccio sarebbe
faticoso da implementare. </p>
 
<p>Il modo più semplice è quello di salvare la sequenza di colori che
costituisce l'intero pattern in un
<b>vettore</b>. Ma prima di
poterlo fare dobbiamo imparare un po' di quello che c'è da sapere
sui vettori.</p>

<h2>Vettori</h2> 

<p>Un vettore è una sequenza ordinata di
variabili unite insieme. È in qualche modo simile ad una ripiano dove ogni
scaffale può contenere un valore separato. Ogni variabile della sequenza
viene identificata dalla sua posizione e può contenere un valore
specifico. Tutte le celle del vettore devono ospitare valori
dello stesso tipo perché in Scala i vettori sono omogenei. È possibile
aggirare questa restrizione utilizzando il tipo di dato
<code>Any</code> che può contenere
 ogni altro tipo di dato. 
Continua comunque ad essere una buona pratica quella di rendere il tipo di
un vettore il più specifico possibile, e cioé se pianificate di memorizzare
solo dei numeri interi in un vettore, create un vettore di interi, non un
Any. </p>

<div style="text-align:center"><img src="lessons/welcome/array/array.png"/></div>

<p>T è il nome del vettore,
T(0) È il nome della prima cella,
T(1) quello della seconda,
T(2) quello della terza, ... Eh sì, la
prima cella è numerata T(0) mentre
l'ultima di un vettore di dimensione N
è T(N-1). Potrebbe sembrare strano
contare iniziando da 0 e non da 1 come si fa solitamente ma alcune ragioni
storiche hanno reso questa pratica inevitabile.</p>

<h3>Utilizzo di base</h3>

<p>Possiamo utilizzare una variabile intera chiamata <i>i</i> per accedere alla
cella attraverso T(i): quando il valore di
<i>i</i> sarà 0, allora T(i) accederà a
T(0) mentre se il valore di <i>i</i> è 10,
allora T(i) accederà a
T(10). La variabile <i>i</i> viene
chiamata <b>indice</b> di T.
<code>T(i)</code> può essere usato alla
stregua di una qualsiasi altra variabile. Possiamo assegnargli un nuovo
valore:</p> 
<pre>T(i) = 78</pre>

<p>Possiamo recuperane ed usare il suo valore: </p>
<pre>x = T(i)</pre>

<p>Possiamo testare il suo valore:</p>
<pre>if (T(i) &gt; 0) {
    // instruzioni...
}</pre>

<p>È molto semplice scorrere l'intero vettore, per esempio per inizializzare ogni cella:</p>

<pre>for (i &lt;- 0 to T.length-1) {
   T(i) = 3
}</pre>

<p>The notation <code>T.length</code> retrieves the length of the
array T,  allowing to build a classical for loop easily.
 Don't
forget to start at <code>0</code> and stop at <code>T.length-1</code>
instead of <code>1</code> to <code>T.length</code> however.</p>

<p>Se volete iterare solo sui valori di T senza tenere traccia dell'indice,
potete semplicemente scrivere:</p>
<pre>for (i &lt;- T) {
  azioni()
}</pre>
<p>
Quello che accade è molto simile a ciò che accadeva nel
costrutto precedente. Semplicemente <code>i to
j</code> ritorna una serie di numeri interi che il costrutto for
utilizza per ripetersi. Attualmente Scala offre modi più eleganti di
scorrere un vettore ed altri tipi di
collezioni di dati ma questo sarà l'argomento di un'altra serie di esercizi
a parte (che peraltro devono ancora essere scritti in PLM).</p>


<h3>Dichiarare un vettore</h3>

 
<p>To declare a variable named <b>T</b> that can store an array of integers,
one should write:</p>
<pre>var T:Array[Int]</pre>

<p> La notazione
<code>[Int]</code> specializza il tipo del vettore (che sarebbe generico)
specificando che ogni sua cella contiene un intero. Similmente un vettore di
booleani si scriverà <code>Array[Boolean]</code>.
</p>

<h3>Allocare un vettore</h3>

<p>Dichiarare una variabile <code>T</code> fa semplicemente posto ad un vettore
riservandogli il <b>nome</b> <code>T</code> per usi successivi ma non gli
riserva dello spazio di memoria per contenere le sue celle. Il vettore non è
ancora stato inizializzato: esso non ha nessun valore. Che potrebbe mai
voler dire <code>T(4)</code> se non abbiamo
ancora stabilito che il vettore è lungo 5 celle?</p>

<p>Prima di tutto dobbiamo dare un valore a <code>T</code>:</p>
<pre>var T = new Array[Int](10)</pre>

<p><code>new</code> significa che noi vogliamo creare qualcosa e
<code>Array[Int](10)</code> significa che
quello che vogliamo creare è un vettore di 10 valori interi. Di consegueza
in memoria viene creato un vettore di 10 celle di interi e la variabile
<code>T</code> ci <b>referenzierà</b> ad esso.</p>

<p>La dimensione del vettore sarà fissa e non potrà essere cambiata dopo la sua
creazione. Potremo conoscere la dimensione di <code>T</code> consultando la
variabile <code>T.length</code>.</p>

<p>While allocating, you can specify the size with a variable:
<code>var T = new
Array[Int](i);</code> In this case, the array's size will be set to the
value of <code>i</code> <i>when <code>new</code> gets called</i>.  The size
of the array still cannot be modified: even if the variable <code>i</code>
changes afterward, the size remains to the value given when it was
allocated.  </p>

<h4>Dichiarazione ed inizializzazione</h4>
<p>Se siete già a conoscenza del contenuto del vostro vettore potete
dichiarare, allocare ed inizializzare tutto contemporaneamente, in un sol
colpo:</p>
<pre>var T = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</pre>

<p>Per conoscere la dimensione del vettore da allocare il compilatore conta i
valori fornitigli. Questo codice è equivalente ad:</p>
<pre>var T = new Array[Int](10);
T(0) = 1
T(1) = 2
...
T(9) = 10</pre>

<p>Che è anche equivalente a:</p>
<pre>var T = new Array[Int](10);
for (i &lt;- 0 to T.length-1) {
  T(i) = i+1
}</pre>


<!-- end of java|scala. python comes back -->


<h3>Vettori e parametri dei metodi</h3>
<p>È perfettamente valido passare un
vettore come parametro di un metodo. Il metodo può quindi utilizzare
questo parametro come se fosse stato definito localmente:</p>
<pre>def haPrima42(vettore:Array[Int]):Boolean = {
  return vettore(0) == 42
}</pre>

<p>Anche dalla parte del chiamante del metodo la cosa è molto semplice:</p>
<pre>var etichetta = new Array[Int] (10)
<span class="comment">// Valore di inizializzazione omesso</span>
if (haPrima42(etichetta)) {
   <span class="comment">// fai qualcosa</span>
}</pre>



<p>I metodi possono anche ritornare vettori
come risultati senza nessuna complicazione. Quì mostrato c'è un metodo che
ritorna un vettore della dimensione
richiesta e riempito di 42.</p>

<pre>def riempiDi42(dimensione:Int):Array[Int] = {
    var ris = new Array[int] (dimensione)
    for (i &lt;- 0 to dimensione -1) {
        ris(i) = 42;
    }
    return ris;
}</pre>

<h2>Traguardo dell'esercizio</h2>

<p>Finalmente! Dopo questa lunga spiegazione possiamo ritornare al nostro
esercizio.</p>
<p>La tua missione è abbastanza semplice. Il tuo codice dovrà memorizzare il
patter di colori osservati nella prima colonna in un
vettore.  Per poterlo fare devi
dichiarare ed allocare un vettore di <code>Color</code>. Ma fai attenzione,
ci sono diversi mondi di diverse dimensioni, usa la funzione
<code>getWorldHeight()</code> per venire a conoscenza dell'altezza del mondo
corrente. Quando il vettore sarà allocato, riempilo leggendo il colore sul
pavimento in ogni locazione (con <code>getGroundColor()</code>).</p>  

<p>Quando sarai riuscito a leggere ed a salvare il pattern della prima colonna
dovrai riapplicarlo su tutte le altre, per esempio eseguendo il metodo che
hai scritto a questo scopo un numero di volte pari al valore di ritorno di
<code>getWorldHeight()</code>. (Ndt potrebbe essere utile sapere che esiste
anche il metodo getWorldWidth() che ci dice la lunghezza del mondo)</p> 
</body></html>