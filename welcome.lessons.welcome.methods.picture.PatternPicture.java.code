void nextV() {
	avance();
	avance();
	avance();
	gauche();
}

void nextSquare() {
	avance();
	avance();
	avance();
	if (!estFaceMur()) {
		avance();
	} else {
		recule();
		recule();
		recule();
	}
}

/**
 * doSideRight : effectue une partie du motif puis revient à la position d'origine.
 * 
 * En raison d'un dysfontionnement de la méthode "setCouleurBrosse(Color c)", la couleur de la brosse doit être modifiée préalablement.
 */
void doSide() {
	gauche();
	avance();
	baisseBrosse();
	leveBrosse();
	recule();
	droite();
	avance();
	baisseBrosse();
	leveBrosse();
	recule();
}

/**
 * Réaliser un "carré" du motif demandé et se place à l'emplacement d'origine.
 */
void doSquare() {
	setCouleurBrosse(Color.RED);
	doSide();
	nextV();
	setCouleurBrosse(Color.BLUE);
	doSide();
	nextV();;
	setCouleurBrosse(Color.GREEN);
	doSide();
	nextV();
	setCouleurBrosse(Color.YELLOW);
	doSide();
	nextV();
}

/**
 * Réalise un "carré" du motif demandé et se place en position pour en réaliser un autre. Si la fin de la ligne est détectée, la buggle se place
 * au point d'origine du dernier carré.
 */
void doLine() {
	doSquare();
	nextSquare();
}

/**
 * Réalise un motif composé de x lignes et de y colonnes. (Exprimées en largeur de motif.)
 */
void doMotif(int x, int y) {
	for (int nbLignes=0; nbLignes<x; nbLignes = nbLignes + 1) {
		for (int nbColonnes=0; nbColonnes<y; nbColonnes = nbColonnes + 1) {
			doLine();
		} for (int pasRetours=0; pasRetours<((y-1)*4); pasRetours = pasRetours + 1) {
			recule();
		} int lignesRestantes=0;
		if (lignesRestantes<x-1) {
			gauche();
		avance();
		avance();
		avance();
		avance();
		droite();
		lignesRestantes = lignesRestantes + 1;
		}
	}
}

public void run() {
	doMotif(2,2);
}
