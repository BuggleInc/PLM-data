def getRankOf(size):    
	for rank in range(getStackSize()):
		if getPancakeRadius(rank) == size:
			return rank
	return -99 # be robust to border cases

debug = True
def showStack():
    s = "maxPos:"+str(maxPos)+" {"
    for rank in range(getStackSize()):
        if isPancakeUpsideDown(rank):
            s = s + "-"
        s = s + str(getPancakeRadius(rank)) + ", "
    s = s + "}"
    print(s)

maxPos = getStackSize()
while True:
    if isSelected() and debug:
        showStack()
        
	maxupside = -1, maxupsidePos = -1
	sorted = True
	for pos in range(getStackSize()):
        if getPancakeRadius(pos) != pos+1 or isPancakeUpsideDown(pos):
            sorted = False
			
        # Search if we are in case 1 on the considered interval
		if (pos<maxPos and not isPancakeUpsideDown(pos) and (maxupside < getPancakeRadius(pos))):
				maxupside = getPancakeRadius(pos)
				maxupsidePos = pos;

    if sorted: # we are done, no need to continue
        if debug:
            print("It's sorted now. Get out of here\n");
		break;

    if maxupside != -1: # Case 1. 
		if maxupside == maxPos: # Case 1.C
			if debug:
				print("Case 1.C; maxupsidePos = "+str(maxupsidePos)+", maxupside = "+str(maxupside))
					if (maxupsidePos+1 != maxPos) {
						flip(maxupsidePos+1);
						flip(maxPos);
					}
					maxPos--;
				} else {
					int pPlus1 = getRankOf(maxupside+1);
					if (pPlus1 > maxupsidePos) {
						if (debug > 0) 
							System.out.println("Case 1.A; maxupsidePos = "+maxupsidePos+", maxupside = "+maxupside+", pPlus1 = "+pPlus1);
						flip(pPlus1+1);showStack(true);
						flip(pPlus1-maxupsidePos);
					} else {
						if (debug > 0) 
							System.out.println("Case 1.B; maxupsidePos = "+maxupsidePos+", maxupside = "+maxupside+", pPlus1 = "+pPlus1);						
						flip(maxupsidePos+1);
						flip(maxupsidePos-pPlus1);
					}
				}
			} else { // Case 2. All pancakes are upside down.
				boolean reverted = true;
				for (int pos=0; reverted && pos<maxPos; pos++) 
					if (getPancakeRadius(pos)!=pos+1)
						reverted = false;
				
				if (reverted) {
					if (debug > 0) 
						System.out.println("Case 2.B");
					for (int i=0; i<maxPos; i++) {
						flip(maxPos);
						if (maxPos>1)
							flip(maxPos-1);
						showStack(true);
					}
				} else { 
					
					int pPlus1 = getRankOf(getStackSize()+1);
					int p;
					for (int radius=maxPos; radius > 0; radius--) {
						p = getRankOf(radius);
						if (p>maxPos)
							p=-99;
						if (pPlus1!=-99 && pPlus1<p) { // we've got the larger p such that p+1 is above p and both are upsideof
							if (debug > 0) 
								System.out.println("Case 2.A; p="+p+", radius="+radius+", pPlus1="+pPlus1);
							flip(p+1);
							if (pPlus1!=0)
								flip(pPlus1+1);
							radius = -1; // We're done with this iteration of the loop
						}
						pPlus1 = p; // shift downward
					}
				}
			}
		}
        
    break
