override def run() {
  
  var width:Int = getWorldWidth()
  var height:Int = getWorldHeight()
  var x:Int=0
  var y:Int=0
  var i:Int=0
  
  def min(a:Int,b:Int):Int ={
    if (a<=b) {return a}
    return b
  }
  

  
  def nexts(i:Int):List[Tuple2[Int,Int]] ={
    var next:List[Tuple2[Int,Int]] = Nil
    for (x<-0 to width-1 ) {
      for (y <- 0 to height-1) {
        if (getIndication(x,y)==i) {
          if (! hasTopWall(x,y)) {
            next=(x,y-1)::next
          }
           if (! hasLeftWall(x,y)) {
             next=(x-1,y)::next
           }
          if (!(x==width-1 || hasLeftWall(x+1,y))) {
            next=(x+1,y)::next
          }
          if (!(y==height-1 || hasTopWall(x,y+1))) {
          	next=(x,y+1)::next
          }
        }
  		}
    }
    return next
  }
  
  while (! hasBaggle(x,y)) {
    if (x<width-1) {
    	x+=1
    } else {
      y+=1
      x=0
    }
  }  
  
  setIndication(x,y,i)
  
  var nextCase:List[Tuple2[Int,Int]]=Nil
  while (i!=width*height) {
    
    nextCase=nexts(i)
    
    
    i+=1
    for (c <- nextCase) {
      
      setIndication(c._1,c._2,min(i,getIndication(c._1,c._2)))
      
    }
    
  }
  
  def move() {
    x=getX()
    y=getY()
    i=getIndication(x,y)-1
    if ((! hasTopWall(x,y)) && i==getIndication(x,y-1)) {
      setDirection(Direction.NORTH)
      forward()
          }
    if ((! hasLeftWall(x,y))&& i==getIndication(x-1,y)) {
      setDirection(Direction.WEST)
      forward()
           }
    if ((!(x==width-1 || hasLeftWall(x+1,y))) && i==getIndication(x+1,y)) {
      setDirection(Direction.EAST)
      forward()
          }
    if ((!(y==height-1 || hasTopWall(x,y+1))) && i==getIndication(x,y+1)) {
      setDirection(Direction.SOUTH)
      forward()
      
      
    }
  }
  
  while (! isOverBaggle()) {
    move()
  }
  pickupBaggle()
}