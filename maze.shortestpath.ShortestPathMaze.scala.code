override def run()
{
  var n = getMondeLargeur();
  var m = getMondeHauteur();
  
  var xSortie = 0;
  var ySortie = 0;
  
  for (x <- 0 to n-1)
  {
    for (y <- 0 to m-1)
    {
      if (aBiscuit(x,y))
      {
        xSortie = x;
        ySortie = y;
      }
    }
  }
  
	noteIndication(xSortie, ySortie, 0, 0);
  return;
  while (!estSurBiscuit()) trouverChemin();
  prendBiscuit();
}

def noteIndication(x:Int, y:Int, i:Int, dir:Int)
{
  var n = getMondeLargeur()-1;
  var m = getMondeHauteur()-1;
  
  setIndication(x,y,i);
  
  dir match
  {
    case 0 =>
      if (x<n && getIndication(x+1,y) > i && !aMurOuest(x+1,y)) noteIndication(x+1, y, i+1, 1);
      if (y<m && getIndication(x,y+1) > i && !aMurNord(x,y+1)) noteIndication(x, y+1, i+1, 2);
      if (x>0 && getIndication(x-1,y) > i && !aMurOuest(x,y)) noteIndication(x-1, y, i+1, 3);
    
    case 1 =>
      if (y>0 && getIndication(x,y-1) > i && !aMurNord(x,y)) noteIndication(x, y-1, i+1, 0);
      if (y<m && getIndication(x,y+1) > i && !aMurNord(x,y+1)) noteIndication(x, y+1, i+1, 2);
      if (x>0 && getIndication(x-1,y) > i && !aMurOuest(x,y)) noteIndication(x-1, y, i+1, 3);
    
    case 2 =>
      if (y>0 && getIndication(x,y-1) > i && !aMurNord(x,y)) noteIndication(x, y-1, i+1, 0);
      if (x<n && getIndication(x+1,y) > i && !aMurOuest(x+1,y)) noteIndication(x+1, y, i+1, 1);
  		if (x>0 && getIndication(x-1,y) > i && !aMurOuest(x,y)) noteIndication(x-1, y, i+1, 3);
    
    case 3 =>
      if (y>0 && getIndication(x,y-1) > i && !aMurNord(x,y)) noteIndication(x, y-1, i+1, 0);
      if (x<n && getIndication(x+1,y) > i && !aMurOuest(x+1,y)) noteIndication(x+1, y, i+1, 1);
      if (y<m && getIndication(x,y+1) > i && !aMurNord(x,y+1)) noteIndication(x, y+1, i+1, 2);
  }
}

def trouverChemin()
{
  var dir = 0;
  var indic = 0;
  var minIndic = 9999;
  var xModDir:List[Int] = List(0, 1, 0, -1);
  var yModDir:List[Int] = List(1, 0, -1, 0);
  
  for (i <- 1 to 4)
  {
    if (!estFaceMur())
    {
      indic = getIndication(getX()+xModDir(i), getY()+yModDir(i));
      
      if (indic < minIndic) dir = i;
    }
  }
  
  indic match
  {
    case 0 => setDirection(Direction.NORD);
    case 1 => setDirection(Direction.EST);
    case 2 => setDirection(Direction.SUD);
    case 3 => setDirection(Direction.OUEST);
  }
  avance();
}