// construction d'une methode 
def isWallAtLeft () : Boolean = {
	left();
	var answer = isFacingWall();
	right();
	return answer;
}

def isDirectionFree (direction : Direction) : Boolean = {
	// save the initial position 
	var pos = getDirection();
	setDirection(direction);
	var answer = !isFacingWall();
	// bring back to the initial position
	setDirection(pos);
	return answer;
}

// ne gere pas le cas si rencontre un Baggle
def northRunnerMode () = {
  // auto-positionnement
  while (getDirection() != Direction.NORTH) {
    right();
  }
  // forward as long as is possible
  while (!isFacingWall()) {
    forward();
  }
}

// convoluted while letting the wall at the left and refresh the sumTurns' variable
def leftFollowerMode (sumTurns : Int, isFirstRun : Boolean) : Int = {
	// to pass out the global variable 
	var x = sumTurns;
	while (((x != 0) && !isDirectionFree(Direction.NORTH))|| isFirstRun) {
		if (!isFacingWall()) {
			forward();
			if (isOverBaggle()) {
				pickupBaggle(); 
				return x;
			} else {
				if (!isWallAtLeft()) {
					left();
					x += 1;
					forward();
					if (isOverBaggle()) {
						pickupBaggle(); 
						return x;
					} else {
						if (!isWallAtLeft()) {
							left();
							x += 1;
							forward();
							if (isOverBaggle()) {
								pickupBaggle(); 
								return x;
							}
						}
					}
				}
			}
		} else { right(); x -= 1;}
	}
	return x;
}

override def run () = {
  var sumTurns = 0;
  var isFirstRun = true;
  while (!isOverBaggle()) {
    var isFirstRun = false;
  	northRunnerMode();
    // let a wall at the left before calling the leftFollowerMode
    while (!isWallAtLeft()) {
      right();
    }
    sumTurns = leftFollowerMode(sumTurns, isFirstRun);
    
  }
}