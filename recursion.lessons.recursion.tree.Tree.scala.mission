<html><head>  <style type="text/css">
    body { font-family: tahoma, "Times New Roman", serif; font-size:10px; margin:10px; }
    code { background:#EEEEEE; }
    pre { background: #EEEEEE;
          margin: 5px;
          padding: 6px;
          border: 1px inset;
          width: 640px;
          overflow: auto;
          text-align: left;
          font-family: "Courrier New", "Courrier", monospace; }
   .comment { background:#EEEEEE;
              font-family: "Times New Roman", serif;
              color:#00AA00;
              font-style: italic; }
  </style>
<<<<<<< HEAD
</head><body>
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Arbres</h2>

<p>Nous allons maintenant dessiner des arbres. Pour cela, nous allons écrire
une fonction doublement récursive de prototype</p> 
<pre>tree(nbPas:Int, longueur:Double, angle:Double, multiplicateur:Double)</pre>

<p>Pour dessiner un arbre à quatre étages, il faut dessiner un tronc de la
taille indiquée, tourner à droite de l'angle indiqué, faire un arbre à 3
étages, tourner à gauche de deux fois l'angle indiqué, faire un autre arbre
à 3 étages, puis revenir à sa position initiale. N'oubliez pas de revenir à
la position initiale !<p>

<p>Si le tronc d'un arbre mesure length à l'étage N, il mesure shrink*length à
l'étage N+1.<p>

<p>Comme vous pouvez le voir, chaque étage de la récursion est représenté par
une couleur distinctive. Pour cela, appelez la fonction
<code>current(step)</code> en lui passant en paramètre l'étage actuel de la
récursion. Elle se chargera de choisir la couleur adéquate. N'effacez pas
vos couleurs quand vous retournez à votre position initiale.</p>

<p>Si vous vous trompez dans votre fonction, il peut facilement devenir très
compliqué de debugger votre code. Vos erreurs se produisant à tous les
étages de la récursion, le dessin peut vite devenir illisible. Pour vous
aider à debugger, vous pouvez utiliser la fonction <code>subtree()</code>
qui dessine un sous-arbre correct. Cette fonction est très (très) semblable
par ailleurs à la fonction que vous tentez d'écrire. La seule différence est
que <code>subtree()</code> ne dessine qu'en noir. Vous pouvez donc
l'utiliser à la place de vos appels récursifs pendant le debug, mais vous
devez changer pour des appels récursifs à votre propre code (quand il
marche) pour avoir les couleurs justes, et donc pour passer l'exercice.</p>  
=======
</head><body>
<!-- Please don't translate this file but l10n/missions/plm.pot (see https://github.com/oster/PLM/wiki/Working-on-translations) -->
<h2>Arbres</h2>

<p>Nous allons maintenant dessiner des arbres. Pour cela, nous allons Ã©crire
une fonction doublement rÃ©cursive de prototype</p> 
<pre>tree(nbPas:Int, longueur:Double, angle:Double, multiplicateur:Double)</pre>

<p>Pour dessiner un arbre Ã  quatre Ã©tages, il faut dessiner un tronc de la
taille indiquÃ©e, tourner Ã  droite de l'angle indiquÃ©, faire un arbre Ã  3
Ã©tages, tourner Ã  gauche de deux fois l'angle indiquÃ©, faire un autre arbre
Ã  3 Ã©tages, puis revenir Ã  sa position initiale. N'oubliez pas de revenir Ã 
la position initiale !<p>

<p>Si le tronc d'un arbre mesure length Ã  l'Ã©tage N, il mesure shrink*length Ã 
l'Ã©tage N+1.<p>

<p>Comme vous pouvez le voir, chaque Ã©tage de la rÃ©cursion est reprÃ©sentÃ© par
une couleur distinctive. Pour cela, appelez la fonction
<code>current(step)</code> en lui passant en paramÃ¨tre l'Ã©tage actuel de la
rÃ©cursion. Elle se chargera de choisir la couleur adÃ©quate. N'effacez pas
vos couleurs quand vous retournez Ã  votre position initiale.</p>

<p>Si vous vous trompez dans votre fonction, il peut facilement devenir trÃ¨s
compliquÃ© de debugger votre code. Vos erreurs se produisant Ã  tous les
Ã©tages de la rÃ©cursion, le dessin peut vite devenir illisible. Pour vous
aider Ã  debugger, vous pouvez utiliser la fonction <code>subtree()</code>
qui dessine un sous-arbre correct. Cette fonction est trÃ¨s (trÃ¨s) semblable
par ailleurs Ã  la fonction que vous tentez d'Ã©crire. La seule diffÃ©rence est
que <code>subtree()</code> ne dessine qu'en noir. Vous pouvez donc
l'utiliser Ã  la place de vos appels rÃ©cursifs pendant le debug, mais vous
devez changer pour des appels rÃ©cursifs Ã  votre propre code (quand il
marche) pour avoir les couleurs justes, et donc pour passer l'exercice.</p>  
>>>>>>> refs/remotes/origin/PLMb08ec186b1914e03e4bcaec7e8fa4fbcab29c7cd
</body></html>
