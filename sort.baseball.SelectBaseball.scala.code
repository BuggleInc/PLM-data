override def run() {
  val nbBases = getNombreBases()
  val nbPos = getNombrePositions()
  var B=0
  var P=0
  var alterneP = 0
  var col = 0
  var col1 = 9999
  var col2 = 9999
  for (B <- 0 to nbBases - 1){
    for (P <- 0 to 1){
      // On pose le trou à la pos initiale
      while (trouverTrou() != B){
        bougerTrouG(P)
      }
      //Tant qu'un Buggle est pas à droite du trou, on bouge le trou
   		while(bonJoueurDroite(B) == 9999){
        bougerTrouD(P)
      }
      deplace((trouverTrou()+1)%nbBases,bonJoueurDroite(B))
			while (getCouleurJoueur(B,P)!=B){
        if (trouverTrou()==B & getCouleurJoueur(trouverTrou(),(P+1)%2)==B){
          bougerTrouD(0)
          bougerTrouG(1)
          bougerTrouD(1)
        }
        
        // On agit même si deux Buggles de la même couleur sont précedent au Trou
        if (getCouleurJoueur(trouverTrou()-1,P)==B && getCouleurJoueur(trouverTrou()-1,(P+1)%2)==B){
          bougerTrouG(P)
          bougerTrouG(P)
          deplace(((trouverTrou()+1)%nbBases),bonJoueurDroite(B))
        }
        // On ne veut pas echanger en boucle Buggle et Trou !
        if (getCouleurJoueur(trouverTrou()-1,P)==B){
          bougerTrouG((P+1)%2)
        }
        // On bouge d'un cran à gauche
        else{
          bougerTrouG(P)
        }
        // Si le Buggle est à gauche on échange de place le Buggle et le Trou
        if (bonJoueurDroite(B) != 9999){
          deplace((trouverTrou()+1)%nbBases,bonJoueurDroite(B))
          }
      }
      
      
    }
  }  
}


def distance(base:Int, position:Int, nbBases:Int):Int={
  //Donne la distance du buggle en position (base,position) à la base de sa couleur
  var dist = 0
  var cBase = base
  val col = getCouleurJoueur(base,position)
  if (col==cBase){
    return 0
  }
  while (cBase != col && col != -1){
    dist += 1
   	cBase = (cBase+1)%nbBases
  }
  return 4 - dist //On parcout le terrain dans l'ordre inverse des aiguilles d'une montre !
}

def trouverTrou():Int = {
  val nbBases = getNombreBases()
  val nbPos = getNombrePositions()
  //Renvoie la base du Trou
  var i=0
  var j=0
  var col=0
  for (i<- 0 to nbBases - 1; j<- 0 to nbPos - 1 ){
    col = getCouleurJoueur(i,j)
    if (col == -1){
      return i
    }
  }
  return 0
}

def bougerTrouG(P:Int){
  val nbBases = getNombreBases()
  deplace((trouverTrou()-1+nbBases)%nbBases,P)  
}

def bougerTrouD(P:Int){
  val nbBases = getNombreBases()
  deplace((trouverTrou()+1+nbBases)%nbBases,P)
}

def bonJoueurDroite(col:Int):Int = {
  var b=trouverTrou()
  val nbBases = getNombreBases()
  var col0=getCouleurJoueur((b+1+nbBases)%nbBases,0)
  var col1=getCouleurJoueur((b+1+nbBases)%nbBases,1)
  if (col0 == col ){
    return 0
  }
	if (col1 == col){
		return 1
  }
  return 9999
}