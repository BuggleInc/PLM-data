override def run() {
  val nbBases = getNombreBases()
  val nbPos = getNombrePositions()
  var liste = new Array[Int](8)
  liste = actualDist(nbBases,nbPos)
  //
  var trou=0
  while (liste != (0,0,0,0,0,0,0,0)){
    trou=trouverTrou(nbBases,nbPos)
    deplace(nbBases,nbPos,trou)
    liste = actualDist(nbBases,nbPos)
  }
  return
}


def distance(base:Int, position:Int, nbBases:Int):Int={
  //Donne la distance du buggle en position (base,position) Ã  la base de sa couleur
  var dist = 0
  var cBase = base
  val col = getCouleurJoueur(base,position)
  while (cBase != col && col != -1){
    dist += 1
   	cBase = (cBase+1)%nbBases
  }
  return dist
}

def actualDist(nbBases:Int,nbPos:Int):Array[Int] = {
  //Actualiste la liste des distances
  var i:Int=0
 	var j:Int=0
  var cpt=0
  var liste=new Array[Int](nbBases * nbPos)
  for (i <- 0 to nbBases-1 ){
    for (j <- 0 to nbPos-1){
      liste(cpt)=distance(i,j,nbBases)
      cpt += 1
    }
  }	
  return liste
}

def trouverTrou(nbBases:Int,nbPos:Int):Int = {
  //Renvoie la base du Trou
  var i=0
  var j=0
  var col=0
  for (i<- 0 to nbBases - 1; j<- 0 to nbPos - 1 ){
    col = getCouleurJoueur(i,j)
    if (col == -1){
      return i
    }
  }
  return 0
}
  
def deplace(nbBases:Int,nbPos:Int,trou:Int){
  var b=(trou+1)%nbBases
  var dist0 = distance(b,0,nbBases)
  var dist1 = distance(b,1,nbBases)
  if ( dist0 <= dist1){
    deplace(b,0)
  }
  else{
    deplace(b,1)
  }
}