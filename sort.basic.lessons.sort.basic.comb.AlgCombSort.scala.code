def combSort() {
	val lgr=2;
	var ecart:Int=lgr ;
	var i:Int=0;
	var inv:Int=0;
	do{
		inv=0;
		if(ecart>1){
			ecart = (ecart.toDouble / 1.3).toInt
		}
		i=0;

		while (i+ecart<lgr){
			if(plusPetitQue(i+ecart,i){
				change(i,i+ecart);
				inv=1	
			}
		}	
	}while(ecart>1 || inv==1);


}

/*
 ecart = lgr;
 faire 
   si ecart>1 alors
     ecart = ecart / 1.3
   i = O
   tant que i+ecart < lgr faire:
     si i et i+ecart doivent être inversés, le faire
     incrémenter i de 1
 tant que l'écart est plus grand que 1 ou que le dernier parcours a inversé au moins un élément*/