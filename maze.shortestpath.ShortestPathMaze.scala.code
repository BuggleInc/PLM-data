override def run() {
  val xMax:Int = getMondeLargeur()-1
  val yMax:Int = getMondeHauteur()-1
  chercheSortie(xMax, yMax) match {
    case (xSortie, ySortie) => ecritIndications(xSortie, ySortie, xMax, yMax, 0) //On remplit les cases.
  }
  

}

def chercheSortie(xMax:Int, yMax:Int):(Int,Int) = {
  var xSortie:Int = 0
  var ySortie:Int = 0
  for (x <- 0 to xMax) {
    for (y <- 0 to yMax) {
      if (aBiscuit(x,y)) {
        xSortie = x
        ySortie = y
      }
    }
  }
  return (xSortie, ySortie)
}

def ecritIndications(x:Int, y:Int, xMax:Int, yMax:Int, cnt:Int) {
  if (getIndication(x, y)>cnt) { //S'il n'y a pas d'indication ou si on a trouvé un plus court chemin,
                                 //on écrit l'indication.
    setIndication(x, y, cnt)
                                 //Puis on regarde où on peut aller :
    if (y-1>=0) {                //Au nord,
      aMurNord(x, y) match {       
        case false => ecritIndications(x, y-1, xMax, yMax, cnt+1)
        case true  => ()
      }
    }
    
    if (x-1>=0) {                //à l'ouest,
      aMurOuest(x, y) match {
        case false => ecritIndications(x-1, y, xMax, yMax, cnt+1)
        case true  => ()
      }
    }
    
    if (y+1<=yMax) {             //au sud,
      aMurNord(x, y+1) match {
        case false => ecritIndications(x, y+1, xMax, yMax, cnt+1)
        case true  => ()
      }
    }

    if (x+1<=xMax) {             //et à l'est.
      aMurOuest(x+1, y) match {
        case false => ecritIndications(x+1, y, xMax, yMax, cnt+1)
        case true  => ()
      }
    }

  }
  
  else {                         //Sinon, on ne fait rien !
    ()
  }
}