$package 

import java.awt.Color

import plm.core.model.Game
import plm.universe.Direction
import plm.universe.bugglequest.BuggleWorldCell
import plm.universe.bugglequest.AbstractBuggle

class RunnerCode extends AbstractBuggle {
	override def forward(i: Int)  { 
		throw new RuntimeException(Game.i18n.tr("Sorry Dave, I cannot let you use forward with an argument in this exercise. Use a loop instead."));
	}
	override def backward(i: Int) {
		throw new RuntimeException(Game.i18n.tr("Sorry Dave, I cannot let you use backward with an argument in this exercise. Use a loop instead."));
	}

  def isFacingWater(): Boolean= {    
    val cell:BuggleWorldCell = (getDirection().intValue()) match {
      case Direction.NORTH_VALUE => getCellFromLesson( getX()                    , (getY()-1) % getWorldHeight())
      case Direction.SOUTH_VALUE => getCellFromLesson( getX()                    , (getY()+1) % getWorldHeight())
      case Direction.WEST_VALUE  => getCellFromLesson((getX()-1)% getWorldWidth(),  getY()                      )
      case Direction.EAST_VALUE  => getCellFromLesson((getX()+1)% getWorldWidth(),  getY()                      )
    }
    return cell.getColor.equals(Color.blue)
  }
  
  var colors = Array(
      new Color(0,155,0),
      new Color(50,155,0),
      new Color(100,155,0),
      new Color(140,155,0),
      new Color(160,155,0),
      new Color(180,155,0),
      new Color(200,155,0),
      new Color(210,155,0), 
      Color.red)
  override def forward()  {
    if (!haveSeenError())
      super.forward();
    var c = getGroundColor();
    if (c.equals(Color.blue)) {
      if (!haveSeenError())
        javax.swing.JOptionPane.showMessageDialog(null, Game.i18n.tr("You fall into water."), Game.i18n.tr("Test failed"), javax.swing.JOptionPane.ERROR_MESSAGE);
      seenError();
    } else {
      var nextColor:Color = null;
      for (i <- 0 to colors.length-1)
        if (colors(i).equals(c)) { 
          if (i==colors.length-1)
            nextColor = colors(i);
          else
            nextColor = colors(i+1);
        }
      setBrushColor(nextColor);
      brushDown();
      brushUp();
    }
  }
  
  def waterOnRight(): Boolean={
    right()
    val res=isFacingWater();
    left()
    return res
  }
  
	override def run() {
		/* BEGIN SOLUTION */
    var nbSteps = 0
    dropBaggle()
    do {
    	if (!waterOnRight()) {
    		right()
        nbSteps += 1
        forward()
      } else if (isFacingWater()) {
        left();
      } else {
        nbSteps += 1
    	  forward()
      }
    } while (!isOverBaggle())
    pickupBaggle()
    writeMessage(nbSteps)
		/* END SOLUTION */
	}
}
