var EXIT_NOT_FOUND = (-1, -1);
var NO_INDICATION = 9999;


override def run() {
	var (exitX, exitY) = findExit();
  
	markExit(exitX, exitY);
	
  var i = 1;
  while (!isCurrentPositionMarked() && i+1 < NO_INDICATION) {
    mark(i);
    i += 1;
  }
}


def findExit() : (Int, Int) = {
  for (x <- 0 to getWorldWidth() - 1) {
  	for (y <- 0 to getWoldHeight() -1) {
      if (hasBaggle(x, y)) return (x, y);
    }
  }
  
  return EXIT_NOT_FOUND; // Should never happen...
}

def markExit(exitX:Int, exitY:Int) {
  setIndication(exitX, exitY, 0);
}

def isCurrentPositionMarked() =
	getIndication(getX(), getY()) != NO_INDICATION;

def getIndicationSafe(x:Int, y:Int) : Int = {
  if (x < 0 || y < 0 || x >= getWorldWidth() || y >= getWorldHeight()) {
    return NO_INDICATION;
  }
      
  return getIndication(x, y);
}
      
def processNeighbor(x:Int, y:Int, xn:Int, yn:Int, minNeighborX:Int, minNeighBorY:Int, min:Int) : Int = {
  var indication = getIndicationSafe(x + xn, y + yn);
  
  if (indication < min) {
    return  indication;
  }
  
  return min;
}

def mark(i:Int) {
  for (x <- 0 to getWorldWidth() - 1) {
    for (y <- 0 to getWorldHeight() - 1) {
      var min = processNeighbor(x, y, -1, 0, NO_INDICATION);
      min = processNeighbor(x, y, 1, 0, min);
      min = processNeighbor(x, y, 0, -1, min);
      min = processNeighbor(x, y, 0, 1, min);
      
      if (min != NO_INDICATION) {
        setIndication(x, y, min + 1)
      }
    }
  }
}