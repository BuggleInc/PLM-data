def memeCouleurSous(a:Int,couleur:Int):Boolean = {
  
  //renvoie si l'autre joueur de couleur est présent sous l'indice a
  for (c <- 0 to a-1) {
    
    if (getCouleurJoueur(index2pos(a)(0),index2pos(a)(0)) == couleur) {
      
      return true
    
    }
    
  }
  
  return false
}

def getCouleurIndice(a:Int):Int = {
  
  return getCouleurJoueur(index2pos(a)(0),index2pos(a)(1))
  
}

def eval(a:Int):Int = {
  
  //évalue le buggle en indice a
	if (memeCouleurSous(a,getCouleurIndice(a))) { //Je le conscidère alors comme le deuxième de ça base
    
    return pos2index(getCouleurIndice(a),1)
    
  } else {
    
    return pos2index(getCouleurIndice(a),0)
  
  }
  
}

def getNombreIndex() :Int = {
  
  //retourne le nombre d'indices
  return getNombreBases()*getNombrePositions()
  
}

def index2pos(index:Int):Array[Int](2) = {
  
  return Array(index/getNombrePositions(),index%getnombrePosition())
  
}

def pos2index(pos:Array[Int](2)):Int = {
  
  return pos(0)*getNombrePositions() + pos(1)
  
}

def getTrouIndex():Int = {
  
  return pos2index(Array(getTrouBase(),getTrouPosition()))
  
}

def deplacer(index:Int) {
  
  deplace(index2pos(index)(0),index2pos(index)(1))
  
}

def tasser() {
  
  for (x <- getTrouIndex()+1 to getNombreIndex()-1) {
    
    deplacer(x)
    
  }
  
}

def switch(a:Int) {
  
  //échange a et le suivant sur le terrain (a est repéré par son index)
  //en supposant que le terrain est tassé
  
  //amener le trou devant a et b
  //
  // a|b|_   a|_|b  _|a|b  b|a|_
  //   >-^   >-^    ^---<
  //
  //tasser
  
  for (x <- getTrouIndex()-1 to a+2 by -1) {
    
    deplacer(x)
    
  }
  
  deplacer(a+1)
  deplacer(a)
  deplacer(a+2)
  
  tasser()
}

override def run() {
  
  tasser()
  
  for (c <- 0 to getNombreIndex()-1) {
    
  	for (x <- 0 to getNombreIndex()-c-2) {
      
    	if (eval(x)>eval(x+1)) {
	
      	switch(x)
	
   	 }
      
 	 }
    
	}
  
}
