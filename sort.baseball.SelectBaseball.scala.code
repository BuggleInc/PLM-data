override def run() {
  val nbBases = getNombreBases()
  val nbPos = getNombrePositions()
  var B=0
  var P=0
  var col = 0
  for (B <- 0 to 1){
    for (P <- 0 to 1){
      col = getCouleurJoueur(B,P) 
      // On regarde si le buggles est de la bonne couleur
      if(!(col == B)){
        bougerTrou(B)
      // Sinon on fait bouger le trou jusqu'à ce que le buggle qui est la bonne couleur soit dans la base b-1
     
      // On fait alors bouger ce buggle jusqu'à ce qu'il soit dans la bonne base
      }
      
    }
  }  
}


def distance(base:Int, position:Int, nbBases:Int):Int={
  //Donne la distance du buggle en position (base,position) à la base de sa couleur
  var dist = 0
  var cBase = base
  val col = getCouleurJoueur(base,position)
  if (col==cBase){
    return 0
  }
  while (cBase != col && col != -1){
    dist += 1
   	cBase = (cBase+1)%nbBases
  }
  return 4 - dist //On parcout le terrain dans l'ordre inverse des aiguilles d'une montre !
}

def trouverTrou():Int = {
  val nbBases = getNombreBases()
  val nbPos = getNombrePositions()
  //Renvoie la base du Trou
  var i=0
  var j=0
  var col=0
  for (i<- 0 to nbBases - 1; j<- 0 to nbPos - 1 ){
    col = getCouleurJoueur(i,j)
    if (col == -1){
      return i
    }
  }
  return 0
}

def bougerTrou(col:Int){
  val nbBases = getNombreBases()
  while(!bonJoueurDroite(col)){
    deplace((trouverTrou()-1+nbBases)%nbBases,0)
  }
}

def bonJoueurDroite(col:Int):Boolean = {
  var b=trouverTrou()
  val nbBases = getNombreBases()
  var col0=getCouleurJoueur((b-1+nbBases)%nbBases,0)
  var col1=getCouleurJoueur((b-1+nbBases)%nbBases,1)
  if (col0==col || col1==col){
    return true
  }
  return false
  
}