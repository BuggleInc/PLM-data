Erreur de compilation :
AlgCombSort:4: error: type mismatch;
 found   : Double
 required: Float
                {test=true; if (gap>1) {gap=gap/1.3}; var i:Int=0;
                                               ^AlgCombSort:5: error: type mismatch;
 found   : Int
 required: ?{def +(x$1: ? >: Float): ?}
Note that implicit conversions are not applicable because they are ambiguous:
 both method int2long in object Int of type (x: Int)Long
 and method int2float in object Int of type (x: Int)Float
 are possible conversion functions from Int to ?{def +(x$1: ? >: Float): ?}
while (i+gap<getValueCount()) {if (isSmaller(i+gap, i)) {swap(i+gap, i); test=false}; i=i+1}
                                             ^AlgCombSort:5: error: overloaded method value + with alternatives:
  (x: Int)Int <and>
  (x: Char)Int <and>
  (x: Short)Int <and>
  (x: Byte)Int
 cannot be applied to (Float)
while (i+gap<getValueCount()) {if (isSmaller(i+gap, i)) {swap(i+gap, i); test=false}; i=i+1}
                                              ^AlgCombSort:5: error: type mismatch;
 found   : Int
 required: ?{def +(x$1: ? >: Float): ?}
Note that implicit conversions are not applicable because they are ambiguous:
 both method int2long in object Int of type (x: Int)Long
 and method int2float in object Int of type (x: Int)Float
 are possible conversion functions from Int to ?{def +(x$1: ? >: Float): ?}
while (i+gap<getValueCount()) {if (isSmaller(i+gap, i)) {swap(i+gap, i); test=false}; i=i+1}
                                                              ^AlgCombSort:5: error: overloaded method value + with alternatives:
  (x: Int)Int <and>
  (x: Char)Int <and>
  (x: Short)Int <and>
  (x: Byte)Int
 cannot be applied to (Float)
while (i+gap<getValueCount()) {if (isSmaller(i+gap, i)) {swap(i+gap, i); test=false}; i=i+1}
                                                               ^